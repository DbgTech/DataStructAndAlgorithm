Windows基础知识：

1. 运行时（静态编译与动态编译）

/MDd  /MD  -  Multi-threaded Debug DLL / Multi-threaded DLL

0:000> k
ChildEBP RetAddr  
0037f760 50c6151e ntdll!RtlAllocateHeap
0037f77c 50c70206 MSVCR90D!_heap_alloc_base+0x5e
0037f7c4 50c6ffbf MSVCR90D!_nh_malloc_dbg+0x2c6
0037f7e4 50c6ff6c MSVCR90D!_nh_malloc_dbg+0x7f
0037f80c 50c7b5eb MSVCR90D!_nh_malloc_dbg+0x2c
0037f82c 50c5db81 MSVCR90D!malloc+0x1b
0037f848 01081fbe MSVCR90D!operator new+0x11
0037f87c 010817b2 RuntimeTest!operator new+0x3e [f:\dd\vctools\crt_bld\self_x86\crt\src\newopnt.cpp @ 18]
0037f88c 010815af RuntimeTest!operator new[]+0x12 [f:\dd\vctools\crt_bld\self_x86\crt\src\newaopnt.cpp @ 15]
0037fad0 01081d58 RuntimeTest!wmain+0x19f [c:\users\administrator\desktop\runtimetest\runtimetest\runtimetest.cpp @ 49]
0037fb20 01081b9f RuntimeTest!__tmainCRTStartup+0x1a8 [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 583]
0037fb28 758a343d RuntimeTest!wmainCRTStartup+0xf [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 403]
0037fb34 771c9832 kernel32!BaseThreadInitThunk+0xe
0037fb74 771c9805 ntdll!__RtlUserThreadStart+0x70
0037fb8c 00000000 ntdll!_RtlUserThreadStart+0x1b

Load Module: C:\Users\Administrator\Desktop\RuntimeTest\Debug\RuntimeDll.dll
DLL Alloc Buffer: 0x00348648
Exe Alloc Buffer: 0x003486E8

如果是动态DLL链接编译的所有模块，EXE和DLL动态分配的内存可以在任何地方释放，
因为它们都是调用 MSVCR*.dll 分配，释放也是调用这个模块。

/MTd  /MT  -  Multi-thread Debug / Multi-threaded 

0:000> k
ChildEBP RetAddr  
0037f674 50af5d7e ntdll!RtlAllocateHeap
0037f690 50ae0eb6 RuntimeDll!_heap_alloc_base+0x5e [f:\dd\vctools\crt_bld\self_x86\crt\src\malloc.c @ 105]
0037f6d8 50ae0c3f RuntimeDll!_heap_alloc_dbg_impl+0x1f6 [f:\dd\vctools\crt_bld\self_x86\crt\src\dbgheap.c @ 427]
0037f6f8 50ae0bdc RuntimeDll!_nh_malloc_dbg_impl+0x1f [f:\dd\vctools\crt_bld\self_x86\crt\src\dbgheap.c @ 239]
0037f720 50ae068b RuntimeDll!_nh_malloc_dbg+0x2c [f:\dd\vctools\crt_bld\self_x86\crt\src\dbgheap.c @ 296]
0037f740 50ae93f1 RuntimeDll!malloc+0x1b [f:\dd\vctools\crt_bld\self_x86\crt\src\dbgmalloc.c @ 56]
0037f75c 50adf04e RuntimeDll!operator new+0x11 [f:\dd\vctools\crt_bld\self_x86\crt\src\new.cpp @ 59]
0037f790 50adde32 RuntimeDll!operator new+0x3e [f:\dd\vctools\crt_bld\self_x86\crt\src\newopnt.cpp @ 18]
0037f7a0 50add77a RuntimeDll!operator new[]+0x12 [f:\dd\vctools\crt_bld\self_x86\crt\src\newaopnt.cpp @ 15]
0037f894 0108156c RuntimeDll!AllocateMem+0x2a [c:\users\administrator\desktop\runtimetest\runtimedll\runtimedll.cpp @ 20]
0037fad0 01081d58 RuntimeTest!wmain+0x15c [c:\users\administrator\desktop\runtimetest\runtimetest\runtimetest.cpp @ 40]
0037fb20 01081b9f RuntimeTest!__tmainCRTStartup+0x1a8 [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 583]
0037fb28 758a343d RuntimeTest!wmainCRTStartup+0xf [f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 403]
0037fb34 771c9832 kernel32!BaseThreadInitThunk+0xe
0037fb74 771c9805 ntdll!__RtlUserThreadStart+0x70
0037fb8c 00000000 ntdll!_RtlUserThreadStart+0x1b

对于静态链接形式，运行时库相关内容被嵌入到对应模块，分配的内存是从当前模块初始化的堆上分配。
而对于动态链接的模块分配内存，无法在静态链接CRT的模块中释放，反过来亦然。

那么同理推之，如果两个模块都是静态链接CRT方式，那么它们动态分配内存也无法相互释放。

所以模块间最好不要相关传递自己通过CRT库函数动态分配的内存。

GlobalAlloc     // 在32位的Windows上已经简化为从进程默认堆上分配内存
HeapAlloc       // 从指定堆上分配内存，有堆句柄HANDLE hHeap指定堆
LocalAlloc      // 基本等价于GlobalAlloc，16位系统上则是另外一回事
malloc          // 从运行时堆上分配
new             // 同malloc
VirtualAlloc    // 系统调用，并非从堆上分配内存，而是直接从地址空间划出内存空间

===============================================================================================
msvcrt.dll 和 msvcr90.dll 区别，前者是为操作系统提供，由微软提供和编译，只供操作系统的模块使用。
而后者是可以下载安装的运行时支持程序中的模块，用于支持用户程序。

代码参看：RuntimeTest

2. 堆 和 栈，运行时堆和线程堆
    进程/线程创建过程中，堆和栈的分配
		进程的第一个线程栈是在 CreateProcessW 函数中通过跨进程操作分配内存来设置栈。
		通过 CreateThread 创建的线程则在其调用的CreateRemoteThread 函数中进行栈创建
    
		堆创建： 
    运行时堆： malloc / new 从运行时堆上分配内存
        在CRT初始化时，会调用到 heap_init 函数进行运行时堆的初始化。最终调用 Kernel32!HeapCreate 进行堆创建。
        
        如果模块采用动态链接形式编译，那么运行时库MSCRT*.dll加载时就已经初始化了，在模块入口处就不需要再初始化了。
        如果模块采用静态链接形式编译，运行时库链接到模块了，在模块加载时进入入口之前就要先执行运行时初始化代码。
        
    进程默认堆： GlobalAlloc / LocalAlloc 从该堆上分配内存
        可以通过函数 kernel32!GetProcessHeap() 获取当前进程的 进程默认堆。
        kernel32!GetProcessHeaps() 函数获取进程的私有堆，其中包括默认堆和通过HeapCreate创建的其他的堆        
        
        其在系统中的位置如下所示：
        
        0:000> dt ntdll!_PEB    
           ......
           +0x014 SubSystemData    : (null) 
           +0x018 ProcessHeap      : 0x003c0000     // 进程默认堆
           +0x01c FastPebLock      : 0x77292100 _RTL_CRITICAL_SECTION    
           ......
           +0x088 NumberOfHeaps    : 1
           +0x08c MaximumNumberOfHeaps : 0x10
           +0x090 ProcessHeaps     : 0x77294760  -> 0x003c0000  // 进程中的堆们   
           ......

3. 进城创建，线程创建与调度
    由 CreateProcessW 发起
        参数：应用程序名字
              命令行
              进程安全属性
              线程安全属性
              是否可继承句柄
              创建标记
              环境变量
              进程当前目录
              启动信息
              进程信息（返回值）
    
        处理环境变量字符串（Ansi->Unicode）
        根据第一个参数或 命令行参数 获取应用程序路径
        打开应用程序文件，创建文件的内存 Section
        
        调用 NtCreateProcess 创建一个进程对象
        
        调用 BasePushProcessParameters 将进程的命令行参数写入新建进程
            即 PEB 结构体中的ProcessParameters成员：
            +0x010 ProcessParameters : _RTL_USER_PROCESS_PARAMETERS
        
        如果不继承父进程句柄，那么对于CUI进程，则需要将 标准输入输出三个句柄复制到新进程
            PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess;
            &ParametersInNewProcess->StandardInput; 
            // 表示取向对于指针 ParametersInNewProcess，成员StandardInput的地址
            // 即 ParametersInNewProcess + StandardInput在结构体偏移
            
        创建线程：
        BaseCreateStack() 首先为新进程中的线程创建 栈
            其中栈大小以及提交值 都是 ImageInformation结构体成员指定，比如ImageInformation.CommittedStackSize
            其实这个结构体内容是从 进程文件（Exe）中提取的信息
            
            在新进程中分配指定栈大小内存，但是只提交其中一部分。
            如果空间允许则还需要添加Guard页（修改最后一页为PAGE_GUARD）
            
        BaseInitializeContext() 为新的线程创建一个初始化上下文，即初始化一个 CONTEXT 结构体
            其中会初始化其中的段寄存器，指令寄存器，栈寄存器等。
            EIP = BaseProcessStartThunk
            ESP = 刚建立的栈
            Eax = 从Image中读取TransferAddress      这个应该是模块入口
            Ebx = 参数，其实是PEB指针
            
        NtCreateThread() 创建并初始化线程对象
        
        如果有调试标记，则调用 DbgUiConnectToDbg 通知调试器
        
        调用 CsrClientCallServer() 通知 CSRSS.exe进程进程创建完毕了
            
        返回参数在前面过程中已经都填写完毕。
            
    NtCreateProcess() 内核中创建进程对象
		首先判断调用来源，R3层的调用需要判断其参数有效性
		调用函数 PspCreateProcess() 继续执行，该函数是NtCreateProcess的实际实现者，创建进程对象，并初始化
			如果有父进程，则根据父进程的基础优先级和CPU亲核心设置子进程，否则单独设置。
			根据参数获取进程映像，尝试获取调试端口对象和异常端口对象。
			调用 ObCreateObject() 方法创建 进程对象（新进程）。
				调用 ObpAllocateObject() 分配对象并填充对象成员，分配内存，按照进程对象格式对内存进行填充。
				创建的进程对象其实是 对象头 加 EPROCESS 结构体

			清空 EPROCESS 结构体，并对其中的成员进行初始化：
			初始化线程列表，用于保存当前进程的线程
			设置异常端口和调试端口  DebugPort ／ ExceptionPort
			设置 设备映像 DeviceMap (确定其作用？？？)
			设置会话ID，父进程ID等
			调用 PspInitializeProcessSecurity 函数初始化进程的安全令牌，或者来自父进程或者来自系统初始化令牌

			调用 MmCreateProcessAddressSpace() 函数创建地址空间，映射系统部分，包括hyper space

			调用 KeInitializeProcess() 函数初始化内核进程对象。
				初始化进程对象的 标准分发对象头，其实就是设置类型并初始化等待列表头
				初始化其中的栈数量，准备好进程列表，线程列表头等
				对于 i386 则还需要设置IOPL 标记。
				
			调用 ObInitProcess() 函数创建进程的 对象表，有父进程则从父进程拷贝带有继承标记的对象元素

			调用 MmInitializeProcessAddressSpace() 初始化新的映像 地址空间
				初始化工作集和互斥体，用于支持分页

				KeAttachProcess() 用于将当前线程挂到新建的进程
					将一个线程挂到目标进程地址空间
					调用 KiAttachProcess() 函数线程到 新剑进程

					MiGetPdeAddress() 用于获取页框，初始化页帧

					设置进程名称
					调用 MmMapViewOfSection() 函数将映像文件映射进内存中。

				最后从新建进程上分离，KeDetachProcess()

			调用 ObInitProcess2() 函数继续初始化
				这个函数在image文件映射进内存之后调用，允许对象管理器根据子系统设置有序的具柄分配

			调用 PspMapSystemDll() 函数映射 系统DLL到目标进程
				调用 MmMapViewOfSection() 函数将 PspSystemDll 中指定的模块映射到系统中

			调用 ObInsertObject() 将进程对象 插入到对象列表中

			如果父进程属于某个 工作集，则将新建进程放到这个工作集中

			将进程加入到活动进程列表，PsActiveProcessHead

			调用 MmCreatePeb() 创建进程的PEB页，并且初始 PEB 值
				挂接到目标进程中，创建 PEB 页面，设置PEB结构中的成员的值，去除挂接

			设置安全属性／审计等一系列工作
			
    NtCreateThread() 内核中创建线程对象
		首先根据调用函数的代码所处环境：内核或R3，如果来自R3则验证所有参数有效性

		调用 PspCreateThread() 继续创建线程
			该函数创建和初始化线程对象，它是NtCreateThead 和 PsCreateSystemThread的实现基础

			创建线程对象之前，先对传入参数进行校验，用户层调用，目标进程不能是系统进程。

			调用 ObCreateObject() 创建线程对象，类似与进程对象，线程对象体为 ETHREAD 结构体
			在指定句柄表中创建一个句柄条目，并返回指向条目的句柄

			初始化 LPC 使用的心好凉和 Lpc回复链，初始化Irp列表

			调用 MmCreateKernelStack() 函数创建线程的内核栈
				分配物理内存，然后获取其虚拟内存。

			调用 MmCreateTeb() 函数创建 TEB ，设置线程的起始地址

			调用 KeInitializeThread() 函数 初始化线程对象。优先级，亲和性和初始参数都是从上下文帧获取
				其中指定了线程第一次被调度时使用的内核函数（第一次调度肯定是先从内核开始执行）
					用户线程从 PspUserThreadStartup() 函数起始
					内核线程从 PspSystemThreadStartup() 函数起始
				thread中的 ServiceTable成员设置，即 SSDT，普通线程指向 KeServiceDescriptorTable[0]

				设置 APC 使用的列表

				调用 KiInitializeContextThread() 设置线程的初始上下文。

				将线程放到进程的线程队列中。

			如果 PspCreateProcessNotifyRoutineCount 不为0，则逐一调用进程创建回调。
				《驱动注册的回调》

			如果 PspCreateThreadNotifyRoutineCount 不为0，则逐一调用线程创建回调。

			将线程内核对象放入内核对象表中，返回线程句柄。

			调用 KeReadyThread() 将进程放入 运行准备好，等待调度。
				进一步调用  KiReadyThread()



    CsrClientCallServer() 通知 csrss.exe进程已经创建完了新的进程
    
    
        
4. 异常处理 过程 SEH
5. TLS
6. 系统调用
7. 界面子系统（消息系统/对话框，模态与非模态）
8. 定时器
9. 内核知识 APC DPC
10. 句柄/事件（命名与匿名）/互斥提（Mutex）/信号量（Semophore）
